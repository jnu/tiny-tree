{"version":3,"file":"BinaryString.js","sourceRoot":"","sources":["../src/BinaryString.ts"],"names":[],"mappings":";;AAKA,6CAAwC;AACxC,qCAA4C;AAM5C;IAAA;QAMY,WAAM,GAAG,CAAC,CAAC;QASX,YAAO,GAAG,CAAC,CAAC;QAMZ,SAAI,GAAG,EAAE,CAAC;IA6EtB,CAAC;IAlEG,KAAK,CAAC,GAAW,EAAE,QAAgB,IAAI;QACnC,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACtB,IAAI,GAAG,GAAG,KAAK,IAAI,uBAAU,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAEvC,EAAE,CAAC,CAAC,KAAK,IAAI,GAAG,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;YACjC,MAAM,IAAI,KAAK,CAAC,eAAe,GAAG,YAAY,KAAK,OAAO,CAAC,CAAC;QAChE,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC;QACjC,IAAI,CAAC,OAAO,IAAI,GAAG,CAAC;QAEpB,IAAI,CAAC,OAAO,EAAE,CAAC;IACnB,CAAC;IAMD,KAAK;QACD,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACzB,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAE3B,OAAO,OAAO,IAAI,OAAO,GAAG,CAAC,EAAE,CAAC;YAC5B,MAAM,KAAK,CAAC,CAAC;YACb,OAAO,IAAI,CAAC,CAAC;QACjB,CAAC;QACD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,OAAO,EAAE,CAAC;IACnB,CAAC;IAOD,OAAO;QACH,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;IACrB,CAAC;IAWD,OAAO;QACH,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACzB,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC3B,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,OAAO,OAAO,IAAI,CAAC,EAAE,CAAC;YAClB,IAAI,SAAS,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;YAC9B,IAAI,IAAI,GAAG,MAAM,IAAI,SAAS,CAAC;YAC/B,MAAM,GAAG,MAAM,GAAG,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC;YACtC,OAAO,GAAG,SAAS,CAAC;YACpB,OAAO,IAAI,2BAAkB,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC;QACD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC;IACzB,CAAC;CAEJ;AAlGD,oCAkGC","sourcesContent":["/**\n * @file Provide an interface for writing binary data into a Base64-encoded\n * string.\n */\n\nimport {floor_log2} from './floor_log2';\nimport {BASE64_INT_TO_CHAR} from './base64';\n\n/**\n * Interface for writing binary data into a Base64-encoded string\n * @class\n */\nexport class BinaryString {\n\n    /**\n     * Data buffer\n     * @type {Number?}\n     */\n    private buffer = 0;\n\n    /**\n     * Word pointer for buffer. With every entry into the buffer, the\n     * pointer gets incremented by the entry's width. Every six characters\n     * may be encoded, so when the pointer exceeds 6, the buffer can be\n     * emptied until the pointer is back under 6.\n     * @type {Number}\n     */\n    private pointer = 0;\n\n    /**\n     * Encoded data as a string of base64 characters\n     * @type {String}\n     */\n    private data = '';\n\n    /**\n     * Write a value to the binary string. This value should be thought of as\n     * an integer representing the binary data to write.\n     * @param  {Integer} val - data to write\n     * @param  {Integer} [width] - optionally specify a width for this data.\n     *                             if none is given, width will be inferred\n     *                             automatically. An error will be thrown if\n     *                             the width is too small to contain the data.\n     */\n    write(val: number, width: number = null) {\n        let buf = this.buffer;\n        let len = width || floor_log2(val) + 1;\n\n        if (width && val >= (0x1 << width)) {\n            throw new Error(`Can't write ${val} in only ${width} bits`);\n        }\n\n        this.buffer = (buf << len) | val;\n        this.pointer += len;\n\n        this._digest();\n    }\n\n    /**\n     * Encode the remaining items in the buffer. Use this when the input stream\n     * is finished to ensure that all data has been encoded.\n     */\n    flush() {\n        let buffer = this.buffer;\n        let pointer = this.pointer;\n        // NB if pointer is at 0, there's nothing to flush.\n        while (pointer && pointer < 6) {\n            buffer <<= 1;\n            pointer += 1;\n        }\n        this.pointer = pointer;\n        this.buffer = buffer;\n        this._digest();\n    }\n\n    /**\n     * Get the binary data as base64. This output does not include padding\n     * characters. This procedure flushes the buffer.\n     * @return {String}\n     */\n    getData() {\n        this.flush();\n        return this.data;\n    }\n\n    /**\n     * Write values from the buffer into the binary encoded string until the\n     * pointer is below 6. Use @link BinaryString#flush to print out all values\n     * regardless of whether they are complete and return the pointer to 0.\n     *\n     * This method is used internally during writes and does not need to be\n     * called explicitly.\n     * @private\n     */\n    _digest() {\n        let buffer = this.buffer;\n        let pointer = this.pointer;\n        let newData = '';\n        while (pointer >= 6) {\n            let remainder = (pointer - 6);\n            let code = buffer >> remainder;\n            buffer = buffer ^ (code << remainder);\n            pointer = remainder;\n            newData += BASE64_INT_TO_CHAR[code];\n        }\n        this.pointer = pointer;\n        this.buffer = buffer;\n        this.data += newData;\n    }\n\n}\n"]}