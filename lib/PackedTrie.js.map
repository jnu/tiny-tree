{"version":3,"file":"PackedTrie.js","sourceRoot":"","sources":["../src/PackedTrie.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @file Small class for querying a binary-encoded Trie\n *\n * TODO - rewrite as a native class. Babel adds a lot of overhead. This class\n * should be tiny and transparent.\n */\n\nimport {ITrie, ISearchOpts, ITestOpts} from './BaseTrie';\nimport {BASE64_CHAR_TO_INT} from './base64';\nimport {\n    TERMINAL,\n    VERSION,\n    HEADER_WIDTH_FIELD,\n    VERSION_FIELD,\n    OFFSET_SIGN_FIELD,\n    OFFSET_VAL_FIELD,\n    CHAR_WIDTH_FIELD,\n    POINTER_WIDTH_FIELD\n} from './constants';\n\n/**\n * Extract a window of bits from a Base64 encoded sequence\n * @param  {String} binary - base64 encoded sequence\n * @param  {Number} start - first bit to read\n * @param  {Number} len - number of bits to read\n * @return {Number} - bits from string, as number\n */\nfunction readBits(binary: string, start: number, len: number) {\n    const startChar = ~~(start / 6);\n    const startBitOffset = start % 6;\n    const endBit = startBitOffset + len;\n    const charLen = Math.ceil(endBit / 6);\n    const mask = (0x1 << len) - 1;\n    let chunk = 0;\n\n    for (let i = 0; i < charLen; i++) {\n        chunk <<= 6;\n        chunk |= BASE64_CHAR_TO_INT[binary[startChar + i]];\n    }\n\n    let rightPadding = endBit % 6;\n    if (rightPadding) {\n        chunk >>= (6 - rightPadding);\n    }\n\n    return chunk & mask;\n}\n\n/**\n * Class for interacting with an encoded trie. The class performs lookups\n * virtually just as fast as a regular trie. The binary data never actually\n * have to be processed as a whole, so instantiation time and memory usage are\n * phenomenally low.\n * @class\n */\nexport class PackedTrie implements ITrie {\n\n    /**\n     * Binary string encoded as Base64 representing Trie\n     * @type {String}\n     */\n    public data: string;\n\n    /**\n     * Pointer offset. Add this to every pointer read from every word in\n     * the trie to obtain the true value of the pointer. This offset is\n     * used to avoid signed integers in the word.\n     * @type {Number}\n     */\n    private offset: number;\n\n    /**\n     * Character table, mapping character to an integer ID\n     * @type {Object}\n     */\n    private table: {[key: string]: number};\n\n    /**\n     * Inverse of character table, mapping integer ID to character.\n     * @type {Array}\n     */\n    private inverseTable: {[key: number]: string};\n\n    /**\n     * Number of bits in one word\n     * @type {Number}\n     */\n    private wordWidth: number;\n\n    /**\n     * Mask for reading the \"last block\" flag in a word\n     * @type {Number}\n     */\n    private lastMask = 0x1;\n\n    /**\n     * Mask for reading the pointer value from a word\n     * @type {Number}\n     */\n    private pointerMask: number;\n\n    /**\n     * Offset of pointer field in a word\n     * @type {Number}\n     */\n    private pointerShift = 1;\n\n    /**\n     * Mask for reading the charTable index in a word\n     * @type {Number}\n     */\n    private charMask: number;\n\n    /**\n     * Offset of charTable index field in a word\n     * @type {Number}\n     */\n    private charShift: number;\n\n    /**\n     * Instantiate a packed binary trie, parsing its headers to configure the\n     * instance for queries.\n     * @constructor\n     * @param  {String} binary - binary string from {@link Trie#encode}\n     * @return {PackedTrie}\n     */\n    constructor(binary: string) {\n        let ptr = 0;\n\n        // Split binary into header and content by checking first field\n        const headerCharCount = readBits(binary, ptr, HEADER_WIDTH_FIELD);\n        ptr += HEADER_WIDTH_FIELD;\n        const header = binary.substr(0, headerCharCount);\n\n        const version = readBits(binary, ptr, VERSION_FIELD);\n        ptr += VERSION_FIELD;\n\n        if (version !== VERSION) {\n            throw new Error(`Version mismatch! Binary: ${version}, Reader: ${VERSION}`);\n        }\n\n        // Main trie data\n        this.data = binary.substr(headerCharCount);\n\n        // compute pointer offset\n        const offsetSign = readBits(header, ptr, OFFSET_SIGN_FIELD);\n        ptr += OFFSET_SIGN_FIELD;\n        let offset = readBits(header, ptr, OFFSET_VAL_FIELD);\n        ptr += OFFSET_VAL_FIELD;\n\n        if (offsetSign) {\n            offset = -offset;\n        }\n\n        // Pointer offset\n        this.offset = offset;\n\n        // interpret the field width within each word\n        let charWidth = readBits(header, ptr, CHAR_WIDTH_FIELD);\n        ptr += CHAR_WIDTH_FIELD;\n\n        let pointerWidth = readBits(header, ptr, POINTER_WIDTH_FIELD);\n        ptr += POINTER_WIDTH_FIELD;\n\n        // Interpret the rest of the header as the charTable\n        let headerFieldChars = Math.ceil(ptr / 6);\n        let charTable = header.substr(headerFieldChars);\n\n        this.table = charTable.split('').reduce((agg, char, i) => {\n            agg[char] = i + 1;\n            return agg;\n        }, { [TERMINAL]: 0 } as {[key: string]: number});\n\n        // Construct inverse table\n        this.inverseTable = [TERMINAL].concat(charTable.split(''));\n\n        // Number of bits in a word\n        this.wordWidth = charWidth + pointerWidth + 1;\n\n        // Mask for reading pointer\n        this.pointerMask = (0x1 << pointerWidth) - 1;\n\n        // Mask for reading characters\n        this.charMask = (0x1 << charWidth) - 1;\n\n        // Offset of charTable\n        this.charShift = 1 + pointerWidth;\n    }\n\n    /**\n     * Test membership in the trie.\n     * @param  {String} str - Search query\n     * @param  {String?} opts.wildcard - See PackedTrie#search wildcard doc\n     * @param  {Boolean?} opts.prefix - See PackedTrie#search prefix doc\n     * @return {Boolean}\n     */\n    test(str: string, {wildcard, prefix}: ITestOpts = {wildcard: null, prefix: false}) {\n        // Delegate to #search with early exit. Could write an optimized path,\n        // especially for the prefix search case.\n        return this.search(str, {wildcard, prefix, first: true}) !== null;\n    }\n\n    /**\n     * Query for matching words in the trie.\n     * @param  {String} str - Search query\n     * @param  {String?} opts.wildcard - Wildcard to use for fuzzy matching.\n     *                                   Default is no wildcard; only match\n     *                                   literal query.\n     * @param  {Boolean?} opts.prefix - Perform prefix search (returns true if\n     *                                  any word exists in the trie starts with\n     *                                  the search query). Default is false;\n     *                                  only match the full query.\n     * @param  {Boolean} opts.first - Return only first match that is found,\n     *                                short-circuiting the search. Default is\n     *                                false; return all matches.\n     * @return {String?|String[]} - Return an optional string result when in\n     *                              first-only mode; otherwise return a list\n     *                              of strings that match the query.\n     */\n    search(str: string, {wildcard, prefix, first}: ISearchOpts = {wildcard: null, prefix: false, first: false}) {\n        if (wildcard && wildcard.length !== 1) {\n            throw new Error(`Wilcard must be a single character; got ${wildcard}`);\n        }\n\n        const {\n            data,\n            offset,\n            table,\n            inverseTable,\n            wordWidth,\n            lastMask,\n            pointerShift,\n            pointerMask,\n            charShift,\n            charMask\n        } = this;\n\n        // List of matches found in the search.\n        const matches = [];\n\n        // Search queue.\n        const queue = [{pointer: 0, memo: '', depth: 0}];\n        const lastDepth = str.length;\n\n        // Do a BFS over nodes for the search query.\n        while (queue.length) {\n            const node = queue.shift();\n            const isLast = node.depth >= lastDepth;\n            const token = isLast ? TERMINAL : str[node.depth];\n            // Flag for matching anything. Note that the overflow beyond the\n            // length of the query in a prefix search behaves as a wildcard.\n            const isWild = token === wildcard || (prefix && isLast);\n            // We're committed to an O(N) scan over the entire node even in\n            // the simple literal-search case, since our structure doesn't\n            // currently guarantee any child ordering.\n            // TODO(joen) ordering is a potential future format optimization.\n            let wordPointer = node.pointer;\n            while (true) {\n                // Optimization: Exit immediately if the char was not found in\n                // the table (meaning there can't be any children in the trie\n                // with this character). Exception is wildcards.\n                if (!isWild && !table.hasOwnProperty(token)) {\n                    break;\n                }\n\n                const bits = wordPointer * wordWidth;\n                const chunk = readBits(data, bits, wordWidth);\n\n                // Read the character index\n                const charIdx = (chunk >> charShift) & charMask;\n\n                // If this character is matched, jump to the pointer given in\n                // this node.\n                if (isWild || charIdx === table[token]) {\n                    const pointer = (chunk >> pointerShift) & pointerMask;\n                    // Find the next char with an inverse map, since we might\n                    // be using a wildcard search.\n                    const newChar = inverseTable[charIdx];\n                    // Stopping condition: searching last block and we hit a terminal\n                    if (isLast && newChar === TERMINAL) {\n                        // Optimization: early exit if we only need first match.\n                        if (first) {\n                            return node.memo;\n                        }\n                        // Store this match.\n                        matches.push(node.memo);\n                        // If we're not matching everything, break out of the\n                        // inner loop.\n                        if (!isWild) {\n                            break;\n                        }\n                    }\n\n                    // Push next node for search, if it's non-terminal.\n                    if (newChar !== TERMINAL) {\n                        queue.push({\n                            pointer: wordPointer + offset + pointer,\n                            depth: node.depth + 1,\n                            memo: node.memo + newChar,\n                        });\n                    }\n                }\n\n                // If this wasn't a match, check if this was the last key in\n                // the block.\n                const last = chunk & lastMask;\n\n                // If this was the last node, the word was not found.\n                if (last) {\n                    break;\n                }\n                // Otherwise increment the pointer to the next sibling key\n                else {\n                    wordPointer += 1;\n                }\n            }\n        }\n\n        // If first was requested it should have returned by now. Otherwise\n        // return the matches list, which may be empty.\n        return first ? null : matches;\n    }\n\n}\n"]}