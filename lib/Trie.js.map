{"version":3,"file":"Trie.js","sourceRoot":"","sources":["../src/Trie.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @file Provides the Trie class\n */\n\nimport {ITrie, ITestOpts, ISearchOpts} from './BaseTrie';\nimport {floor_log2} from './floor_log2';\nimport {BinaryString} from './BinaryString';\nimport {\n    TERMINAL,\n    TERMINUS,\n    VERSION,\n    HEADER_WIDTH_FIELD,\n    VERSION_FIELD,\n    OFFSET_SIGN_FIELD,\n    OFFSET_VAL_FIELD,\n    CHAR_WIDTH_FIELD,\n    POINTER_WIDTH_FIELD\n} from './constants';\n\n/**\n * Trie node.\n */\nexport interface INode {\n    [key: string]: INode;\n}\n\n/**\n * Metadata used to process trie.\n */\ninterface INodeMeta {\n    __visited__: number;\n    __willVisit__: number;\n    __idx__: number;\n    __parents__: IChunk[];\n}\n\n/**\n * Interface of a node as it is being processed in the trie.\n */\ntype IInternalNode = INode & INodeMeta;\n\n/**\n * Long-form information to be encoded in binary format.\n */\ninterface IChunk {\n    char: string;\n    idx: number;\n    offset: number;\n    last: boolean;\n}\n\n/**\n * A structure to provide efficient membership tests for a set of strings\n * @class\n */\nexport class Trie implements ITrie {\n\n    public root: INode;\n\n    public frozen: boolean;\n\n    /**\n     * Typically no arguments are needed, but it's possible to instantiate a\n     * Trie from a JSON object that represents it (@see Trie#toJSON).\n     * @constructor\n     * @param  {Object} tree - a trie given as a vanilla JS tree. This will be\n     *                         used as the root node.\n     * @return {Trie}\n     */\n    constructor(tree: INode = {}) {\n        this.root = tree;\n        this.frozen = false;\n    }\n\n    /**\n     * Insert a word into the trie. Insertions into a frozen trie will throw\n     * an error. The\n     * @param  {String} str - string to insert. Note the \\u0000 character is\n     *                        disallowed.\n     * @return {Trie} - this\n     */\n    insert(str: string) {\n        // This trie insert algorithm can't guarantee safe inserts on the DAWG\n        // produced by freezing.\n        if (this.frozen) {\n            throw new SyntaxError(`Can't insert into frozen Trie`);\n        }\n\n        const lastNode = str.split('').reduce((node, char) => {\n            if (char === TERMINAL) {\n                throw new TypeError(`Illegal string character ${TERMINAL}`);\n            }\n            let nextNode = node.hasOwnProperty(char) ?\n                node[char] :\n                (node[char] = {});\n            return nextNode;\n        }, this.root);\n\n        // Terminate the string. Using a constant terminus is not necessary\n        // (and is not be possible in cloned tries), but it uses slightly less\n        // memory and could make certain bugs more obvious.\n        lastNode[TERMINAL] = TERMINUS;\n\n        return this;\n    }\n\n    /**\n     * Test membership in the trie.\n     * @param  {String} str - Search query\n     * @param  {String?} opts.wildcard - See Trie#search wildcard doc\n     * @param  {Boolean?} opts.prefix - See Trie#search prefix doc\n     * @return {Boolean}\n     */\n    test(str: string, {wildcard, prefix}: ITestOpts = {wildcard: null, prefix: false}) {\n        // When there are no wildcards we can use an optimized search.\n        if (!wildcard) {\n            let node = this.root;\n            const match = str.split('').every(char => !!(node = node[char]));\n            return !!match && (prefix || node.hasOwnProperty(TERMINAL));\n        }\n\n        // Unoptimized path: delegate to #search with short-circuiting.\n        return !!this.search(str, {wildcard, prefix, first: true});\n    }\n\n    /**\n     * Query for matching words in the trie.\n     * @param  {String} str - Search query\n     * @param  {String?} opts.wildcard - Wildcard to use for fuzzy matching.\n     *                                   Default is no wildcard; only match\n     *                                   literal query.\n     * @param  {Boolean?} opts.prefix - Perform prefix search (returns true if\n     *                                  any word exists in the trie starts with\n     *                                  the search query). Default is false;\n     *                                  only match the full query.\n     * @param  {Boolean} opts.first - Return only first match that is found,\n     *                                short-circuiting the search. Default is\n     *                                false; return all matches.\n     * @return {String?|String[]} - Return an optional string result when in\n     *                              first-only mode; otherwise return a list\n     *                              of strings that match the query.\n     */\n    search(str: string, {wildcard, prefix, first}: ISearchOpts = {wildcard: null, prefix: false, first: false}) {\n        // Validate wildcard matching.\n        if (wildcard && wildcard.length !== 1) {\n            throw new Error(`Wildcard length must be 1; got ${wildcard.length}`);\n        }\n\n        // List of search hits. Note: not used in `first` mode.\n        const matches = [];\n\n        // Do a BFS over nodes to with fuzzy-matching on the wildcard.\n        const queue = [{data: this.root, depth: 0, memo: ''}];\n        const lastDepth = str.length;\n\n        while (queue.length) {\n            const node = queue.shift();\n            // The search is a hit if we've reached the proper depth and the\n            // node is terminal. The search can break if the query was for\n            // first-only.\n            if (node.depth >= lastDepth) {\n                if (node.data.hasOwnProperty(TERMINAL)) {\n                    if (first) {\n                        return node.memo;\n                    }\n                    // Otherwise store this result and continue searching.\n                    matches.push(node.memo);\n                }\n                // Discard the node and move on if we can; prefix matches need\n                // to traverse everything.\n                if (!prefix) {\n                    continue;\n                }\n            }\n            // Special case: prefix searches overflow the length of the search\n            // queries. Treat these overflowing chars as wildcards.\n            const isPfXOverflow = prefix && node.depth >= lastDepth;\n            // Add any candidate children nodes to the search queue.\n            const token = str[node.depth];\n            // Wildcard could be any child (except terminal).\n            if (token === wildcard || isPfXOverflow) {\n                Object.keys(node.data).forEach(n => {\n                    if (n !== TERMINAL) {\n                        queue.push({\n                            data: node.data[n],\n                            depth: node.depth + 1,\n                            memo: node.memo + n,\n                        });\n                    }\n                });\n            } else {\n                if (node.data.hasOwnProperty(token)) {\n                    queue.push({\n                        data: node.data[token],\n                        depth: node.depth + 1,\n                        memo: node.memo + token,\n                    });\n                }\n            }\n        }\n\n        // A `first` search will have broken out and returned a literal by now;\n        // other searches just return whatever is in matches.\n        return first ? null : matches;\n    }\n\n    /**\n     * Clone a Trie. This will unfreeze a frozen trie.\n     * @return {Trie}\n     */\n    clone() {\n        return new Trie(this.toJSON());\n    }\n\n    /**\n     * Freeze the Trie, deduping suffixes. Given the assumption that there will\n     * not be new entries into a trie, redundant suffix branches can be merged.\n     * @return {Trie} - This trie (freezing modifies it in place)\n     */\n    freeze() {\n        // Freezing is idempotent\n        if (this.frozen) {\n            return this;\n        }\n\n        // Create a store for fast lookup of matching suffixes during walk\n        const suffixTree: {[key: string]: INode[]} = {};\n\n        // Walk the entire trie depth first, de-duping suffixes\n        let node = this.root;\n        let stack: {current: INode, char: string, parent: INode}[] = [];\n        let depthStack = [node];\n\n        // Iterate over tree nodes, pushing children onto the depthStack so\n        // that the items pushed on to the main `stack` are in the correct\n        // order for a second traversal.\n        while (depthStack.length) {\n            node = depthStack.pop();\n\n            Object.keys(node).forEach(char => {\n                if (char[1] === '_') {\n                    return;\n                }\n                let current = node[char];\n                stack.push({\n                    current: current,\n                    char: char,\n                    parent: node\n                });\n                depthStack.push(current);\n            });\n        }\n\n        // Now do node processing, joining / deduping suffix lines.\n        while (stack.length) {\n            let { char, parent, current } = stack.pop();\n\n            // Find potential suffix duplicates with a char lookup\n            if (suffixTree.hasOwnProperty(char)) {\n                let suffixMeta = suffixTree[char];\n\n                // Find a matching suffix by comparing children. Since\n                // deduping is depth-first, comparing children by identity\n                // is a valid way to check if this node is a duplicate.\n                let match = suffixMeta.find(other => {\n                    let oKeys = Object.keys(other);\n                    let cKeys = Object.keys(current);\n                    return (\n                        oKeys.length === cKeys.length &&\n                        oKeys.every(key => other[key] === current[key])\n                    );\n                });\n\n                // If this node is a dupe, update its parent reference to\n                // point to the cached match.\n                if (match) {\n                    parent[char] = match;\n                }\n                // If the node is novel, cache it for future checks.\n                else {\n                    suffixMeta.push(current);\n                }\n            }\n            // If this char is novel, create a new suffixMeta entry\n            else {\n                suffixTree[char] = [current];\n            }\n        }\n\n        // Flag the tree as frozen\n        this.frozen = true;\n\n        return this;\n    }\n\n    /**\n     * Encode the Trie in a binary format. This format stores the trie or DAWG\n     * efficiently and still allows for fast queries.\n     * @return {Object}\n     */\n    encode() {\n        const chunks: IChunk[] = [];\n        const queue = [this.root];\n        const charTable = new Set();\n        const visitCode = Date.now();\n        let offsetMin = Infinity;\n        let offsetMax = -Infinity;\n\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        // Encode trie\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        while (queue.length) {\n            let node = queue.shift() as IInternalNode;\n            let keys = Object.keys(node).filter(k => k[1] !== '_');\n            let n = keys.length;\n\n            node.__visited__ = visitCode;\n            let nodeChunkIndex = node.__idx__ = chunks.length;\n\n            // Fill in the parent chunks that are waiting to find out what\n            // index this chunk gets assigned\n            if (node.__parents__) {\n                node.__parents__.forEach(chunk => {\n                    let offset = chunk.offset = nodeChunkIndex - chunk.idx;\n                    if (offset < offsetMin) {\n                        offsetMin = offset;\n                    }\n                    if (offset > offsetMax) {\n                        offsetMax = offset;\n                    }\n                });\n            }\n\n            keys.forEach((char, i) => {\n                let child = node[char] as IInternalNode;\n                let chunkIdx = chunks.length;\n                let lastInLevel = i === n - 1;\n\n                let newChunk: IChunk = {\n                    char: char,\n                    idx: chunkIdx,\n                    offset: null,\n                    last: lastInLevel\n                };\n\n                // If the child has been visited, jump directly to that node\n                // instead of creating a new entry.\n                if (child.__visited__ === visitCode) {\n                    let idx = child.__idx__;\n                    let offset = newChunk.offset = idx - chunkIdx;\n                    if (offset < offsetMin) {\n                        offsetMin = offset;\n                    }\n                    if (offset > offsetMax) {\n                        offsetMax = offset;\n                    }\n                }\n                // If child is novel, add it to the process queue and add an\n                // instruction to jump there.\n                else {\n                    if (child.__willVisit__ === visitCode) {\n                        child.__parents__.push(newChunk);\n                    } else {\n                        child.__willVisit__ = visitCode;\n                        child.__parents__ = [newChunk];\n                    }\n                    queue.push(child);\n                }\n\n                // Add a new chunk to the array\n                chunks.push(newChunk);\n\n                // Ensure that the char is in the chartable\n                charTable.add(char);\n            });\n        }\n\n        // Assign a unique integer ID to each character. The actual ID is\n        // arbitrary. For the convenience of not having to serialize the \\0\n        // character, the TERMINAL is always encoded at the 0 index, and it is\n        // not included in the charTable.\n        const charTableAsArray = Array.from(charTable)\n            .filter(char => char !== TERMINAL);\n        const charMap = charTableAsArray.reduce((agg, char, i) => {\n            agg[char] = i + 1;\n            return agg;\n        }, { [TERMINAL]: 0 });\n        // Determine the number of bits that can index the entire charTable.\n        const charEncodingWidth = floor_log2(charTableAsArray.length) + 1;\n\n        const pointerRange = offsetMax - offsetMin;\n        const pointerEncodingWidth = floor_log2(pointerRange) + 1;\n\n        // The binary with of node encodings is variable. There are three parts\n        // that get encoded:\n        //\n        //  1) character index (corresponding to character table),\n        //  2) pointer (as offset from start of word to next node),\n        //  3) last (flag to indicate whether this is the last block in this\n        //     subtree)\n        //\n        // The width of the first two items are determined as the binary width\n        // of the unsigned integer representing the maximum in the range. The\n        // width of the third is a constant 1 binary digit.\n        //\n        // E.g., if the charTable is 28 characters in length, then the binary\n        // digit representing 27 (the last item in the array) is:\n        //\n        //   1 1011\n        //\n        // So the width is determined to be 5. If the pointer range has a\n        // maximum of 250, represented in binary as:\n        //\n        //   1111 1010\n        //\n        // Giving a width of 8. With these specifications, a node such as:\n        //\n        //   charIndex: 8, pointer: 100, last: false\n        //\n        // Would be encoded as:\n        //\n        //   --A---|----B-----|C|XXXXX\n        //   0100 0|011 0010 0|1|00 00\n        //\n        // Which can be represented in Base64 as:\n        //\n        //   QyQ==\n        //\n        // TODO could be more clever and combine the first two fields.\n\n        const encodedTrie = new BinaryString();\n\n        chunks.forEach(chunk => {\n            let { char, offset, last } = chunk;\n            encodedTrie.write(charMap[char], charEncodingWidth);\n            encodedTrie.write(offset - offsetMin, pointerEncodingWidth);\n            encodedTrie.write(+last, 1);\n        });\n\n        encodedTrie.flush();\n\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n        // Encode header\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n        const headerString = new BinaryString();\n        // TODO encode unicode\n        const outputCharTable = charTableAsArray.join('');\n\n        // Header width designates the ASCII-character count at the beginning\n        // of the file that encodes the header.\n        const headerWidth = Math.ceil((\n            HEADER_WIDTH_FIELD +\n            VERSION_FIELD +\n            OFFSET_SIGN_FIELD +\n            OFFSET_VAL_FIELD +\n            CHAR_WIDTH_FIELD +\n            POINTER_WIDTH_FIELD\n        ) / 6) + outputCharTable.length;\n        // Mark the offset as positive or negative\n        const offsetSign = +(offsetMin < 0);\n\n        headerString.write(headerWidth, HEADER_WIDTH_FIELD);\n        headerString.write(VERSION, VERSION_FIELD);\n        headerString.write(offsetSign, OFFSET_SIGN_FIELD);\n        headerString.write(offsetSign ? -offsetMin : offsetMin, OFFSET_VAL_FIELD);\n        headerString.write(charEncodingWidth, CHAR_WIDTH_FIELD);\n        headerString.write(pointerEncodingWidth, POINTER_WIDTH_FIELD);\n        headerString.flush();\n\n        // Concat the header, charTable, and trie\n        return `${headerString.getData()}${outputCharTable}${encodedTrie.getData()}`;\n    }\n\n    /**\n     * Implement JSON API for serialization. Tries can be serialized and\n     * restored using JSON and the constructor. Note that tries (even frozen\n     * ones) *do not serialize efficiently in JSON*. For memory-efficient\n     * tries, @see Trie#encode.\n     *\n     * @example\n     *   > trie = new Trie();\n     *   > ['foo', 'fudge', 'nudge'].forEach(s => trie.insert(s));\n     *   > let jsonStr = JSON.stringify(trie);\n     *   > let restored = new Trie(JSON.parse(jsonStr));\n     *   > ['foo', 'fudge', 'nudge'].every(s => restored.test(s));\n     *   // -> true\n     *\n     * @return {Object} Vanilla JS object\n     */\n    toJSON() {\n        // Remove any private fields on serialization, e.g. __visited__\n        let str = JSON.stringify(this.root, (k, v) => {\n             if (k[1] === '_') {\n                return undefined;\n             }\n             return v;\n        });\n        return JSON.parse(str);\n    }\n\n}\n"]}